<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KeeperRL Struct Extractor from GitHub</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }		
        h1, p, h2 {
            margin: 0.5em 0;
        }
        #result {
            white-space: pre-wrap;
            background-color: #f4f4f4;
            border: 1px solid #ddd;
            margin-top: 10px;
            height: 300px;
            overflow-y: auto;
        }
        .progress-container {
            margin-top: 10px;
        }
        .progress-bar {
            width: 100%;
            background-color: #f3f3f3;
        }
        .progress {
            width: 0;
            height: 20px;
            background-color: #4caf50;
            text-align: center;
            color: white;
        }
    </style>
</head>
<body>
    <h1>C++ Struct Extractor from GitHub</h1>
	<h3 style="text-align: center;">
		In C++, a <strong>struct</strong> is a custom data type that groups different variables under one name, allowing for mixed types. It helps organize related data into a single unit. Structs are important for modding <em>KeeperRL</em> because they are often filled with data from our mod files. This webpage connects to <a href="https://github.com">GitHub</a> to analyze how the structs in Michal's <em>KeeperRL</em> source code could be populated when writing mod files. 
		<br><br>
		For example, in the modded <strong>attributes.txt</strong>, we populate <code>AttrInfo</code> with the following fields: <code>{bodyPartInjury}</code>, <code>name</code>, <code>{viewId}</code>, <code>adjective</code>, <code>absorptionCap</code>, <code>modifierVariation</code>, <code>wishedItemIncrease</code>, <code>isAttackAttr</code>, <code>{meleeFX}</code>, <code>{help}</code>, and <code>{onAttackedEffect}</code>. 
		<br><br>
		From the Vanilla <strong>attributes.txt</strong>: 
		<code>"DAMAGE" { name = "damage" viewId = { "damage_icon" } adjective = "dangerous" absorptionCap = 25 isAttackAttr = true help = "Base damage value of melee attacks." }</code>
		<br><br> Structs can also contain other structs, so even if there is no text file dedicated to a struct,
		some parts of files will be populating child structs.
	</h3>
	<div class="usage-info" id="usageInfo">
		Checking GitHub API usage...
	</div>	
    <p>Enter a GitHub repository URL (e.g., https://github.com/username/repo):</p>
    <input type="text" id="repoInput" value="https://github.com/miki151/keeperrl" size="50">
    <button onclick="extractStructsFromRepo()">Extract Structs</button>

    <h2>Current Process:</h2>
    <p id="statusLabel">Waiting for input...</p>

    <h2>File Iteration Progress:</h2>
    <div class="progress-container">
        <div class="progress-bar">
            <div id="fileProgress" class="progress"></div>
        </div>
    </div>

    <h2>Extracted Structs:</h2>
    <div id="result"></div>

    <script>
        async function extractStructsFromRepo() {
            const repoUrl = document.getElementById('repoInput').value;
            const resultDiv = document.getElementById('result');
            const fileProgress = document.getElementById('fileProgress');
            const statusLabel = document.getElementById('statusLabel');
            
            resultDiv.innerHTML = '';
            fileProgress.style.width = '0%';
            statusLabel.innerHTML = 'Fetching repository contents...';

            try {
                // Extract owner and repo name from GitHub URL
                const repoParts = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
                if (!repoParts) {
                    throw new Error('Invalid GitHub repository URL');
                }

                const owner = repoParts[1];
                const repo = repoParts[2];

                // GitHub API URL for repository content (root directory, master branch)
                const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/`;

                // Fetch the repository contents from GitHub
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    throw new Error('Error fetching repository contents from GitHub');
                }

                const files = await response.json();
                const sourceFiles = files.filter(file => file.type === 'file' && (file.name.endsWith('.h')));
                const totalFiles = sourceFiles.length;

                if (totalFiles === 0) {
                    resultDiv.innerHTML = 'No .h files found.';
                    statusLabel.innerHTML = 'No files found.';
                    return;
                }

                let fileIndex = 0;

                // Iterate over each source file and process .h
                for (const file of sourceFiles) {
                    // Update the file iteration progress bar
                    fileIndex++;
                    const fileProgressPercent = (fileIndex / totalFiles) * 100;
                    fileProgress.style.width = `${fileProgressPercent}%`;
                    fileProgress.innerText = `${Math.round(fileProgressPercent)}%`;

                    statusLabel.innerHTML = `Processing file: ${file.name} (${fileIndex}/${totalFiles})`;

                    const rawUrl = file.download_url;
                    const fileResponse = await fetch(rawUrl);
                    const fileContent = await fileResponse.text();

                    // Remove comments from the file content
                    let cleanedContent = fileContent.replace(/\/\/.*|\/\*[^]*?\*\//g, '');

                    // Normalize the file content by replacing all whitespace with a single space
                    const normalizedContent = cleanedContent.replace(/\s+/g, ' ');

                    // Extract structs from each file and update the output
                    extractAndDisplayStructs(normalizedContent, file.name);
                }

                statusLabel.innerHTML = 'Processing complete.';
                fileProgress.style.width = '100%';
                fileProgress.innerText = '100%';
            } catch (error) {
                resultDiv.innerHTML = `Error: ${error.message}`;
                statusLabel.innerHTML = 'Error occurred.';
            }
        }

function extractAndDisplayStructs(sourceCode, fileName) {
    const resultDiv = document.getElementById('result');
    const structs = sourceCode.split('struct'); // Split the source into structs
    let output = '';

    // Iterate through each struct definition
    structs.forEach(struct => {
        if (struct.trim()) { // Check if not empty
            // Match the first word (struct name)
            const structNameMatch = struct.match(/^\s*(\w+)/);
            if (structNameMatch) {
                let structName = structNameMatch[1].trim();
		if (structName == "LakeInfo") { structName = "BiomeInfo" } //Always gets this wrong.
                const membersOutput = [];
                let serializeLine = '';

                // Split the struct body into lines for easier processing
                const lines = struct.split(';');
                lines.forEach((line, index) => {
                    const trimmedLine = line.trim();
                    if (trimmedLine.startsWith('SERIALIZE_ALL')) {
                        serializeLine = trimmedLine; // Capture the SERIALIZE_ALL line
                    } else {
                        // Collect member definitions
                        if (index === 0) {
                            // Remove the first word (type) and any opening '{'
                            const cleanedLine = trimmedLine.replace(/^\s*\w+\s*\{?/, '').trim();
                            membersOutput.push(cleanedLine); // Add the cleaned member definition
                        } else {
                            membersOutput.push(trimmedLine); // For subsequent lines, push the line as is
                        }
                    }
                });

                // If no members or SERIALIZE_ALL line, skip this struct
                if (serializeLine || membersOutput.length > 0) {
                    // Create the usage section based on the SERIALIZE_ALL line
                    let usageSection = serializeLine.replace('SERIALIZE_ALL(', `<b>${structName}</b> `);
                    usageSection = usageSection
                        .replace(/\s+/g, ' ') // Remove any whitespace
                        .replace(/,/g, ' ') // Replace commas with spaces
                        .replace(/\);/g, '') // Remove any ); occurrences
                        .replace(/NAMED\(/g, '') // Replace NAMED( with {
                        .replace(/OPTION\(/g, '') // Replace OPTION( with {
                        .replace(/SKIP\(/g, '') // Replace SKIP( with {
                        .replace(/\)/g, '') // Replace ) with }
                        .replace('  ', ' ') // Replace double spaces
                        .slice(0, -2); // Remove the last 2 characters

                    // Store member names and types for later usage
                    const memberNamesAndTypes = membersOutput.map(member => {
                        const parts = member.replace('SERIAL(', '').replace(')', '').split(/\s+/);
                        return {
                            name: parts[1],
                            type: parts[0]
                        };
                    });

                    // Process each member and update the usageSection string if the member name is found in the usageSection
                    memberNamesAndTypes.forEach(({ name, type }) => {
                        // List of basic types that don't need enclosing
                        const basicTypes = ['bool', 'int', 'string', 'double'];

                        // Check if the type doesn't contain any of the basic types
                        if (!basicTypes.some(typeCheck => type.includes(typeCheck))) {
                            // If member name is found in the usageSection, enclose it in {}
                            if (usageSection.includes(name)) {
                                usageSection = usageSection.split(name).join(`{${name}}`); // Enclose name in {}
                            }
                        }
                    });

                    // Create a copy of the usageSection with member names replaced by their types
                    let typeReplacedUsageSection = usageSection;

                    memberNamesAndTypes.forEach(({ name, type }) => {
                        // Replace member name in the type-replaced usage section without regex
                        if (typeReplacedUsageSection.includes(name)) {
                            typeReplacedUsageSection = typeReplacedUsageSection.split(name).join(type);
                        }
                    });

                    usageSection = usageSection
                        .replace('SUBCLASS({Summon}', 'summon')
                        .replace('SUBCLASS({GenericModifierEffect}', 'effect')
						.replace('ITEM_TYPE_INTERFA', '')
						.replace('withRoundBracket', '')						
						.replace('roundBracket', '');

                    // Append a new line with the modified typeReplacedUsageSection to the output
                    if (usageSection.trim()) {
                        output += `${usageSection.trim()}\n<details>File: ${fileName.trim()}
Struct Name: ${structName.trim()}
Syntax showing data types: ${typeReplacedUsageSection.trim()}
${membersOutput.join('\n')}
${serializeLine.trim()}
</details><br/>`;
                    }
                }
            }
        }
    });

    resultDiv.innerHTML += output; // Append to result div
}



		// Function to fetch GitHub API usage data
		async function fetchUsageData() {
			try {
				const response = await fetch('https://api.github.com/rate_limit');
				const data = await response.json();
				const limit = data.rate.limit;
				const remaining = data.rate.remaining;
				const resetTime = new Date(data.rate.reset * 1000);
				
				// Calculate time left in seconds
				const now = new Date();
				const timeLeft = Math.floor((resetTime - now) / 1000); // Difference in seconds
				
					// Only show usage information if relevant
				if (remaining < limit) {
					const usageInfo = `
						You have <span class="highlight">${remaining}</span> requests remaining from <span class="highlight">${limit}</span>.
						<br>Next Reset Time (UTC): <span class="highlight">${resetTime.toLocaleString('en-GB', { timeZone: 'UTC' })}</span>
					`;
					document.getElementById('usageInfo').innerHTML = usageInfo;
				} else {
					document.getElementById('usageInfo').innerHTML = '';
				}
			} catch (error) {
				document.getElementById('usageInfo').innerHTML = 'Error fetching GitHub API usage data.';
				console.error('Error:', error);
			}
		}

		// Fetch the usage data on page load
		fetchUsageData();
		setInterval(fetchUsageData, 60000);
    </script>
</body>
</html>
