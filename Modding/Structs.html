<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KeeperRL Struct Extractor from GitHub</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }		
        h1, p, h2 {
            margin: 0.5em 0;
        }
        #result {
            white-space: pre-wrap;
            background-color: #f4f4f4;
            border: 1px solid #ddd;
            margin-top: 10px;
            height: 300px;
            overflow-y: auto;
        }
        .progress-container {
            margin-top: 10px;
        }
        .progress-bar {
            width: 100%;
            background-color: #f3f3f3;
        }
        .progress {
            width: 0;
            height: 20px;
            background-color: #4caf50;
            text-align: center;
            color: white;
        }
    </style>
</head>
<body>
    <h1>C++ Struct Extractor from GitHub</h1>
	<h3 style="text-align: center;">
		In C++, a struct is a custom data type that lets you group different kinds of variables together under one name, even if they have different types. It's used to organize related data into one unit. We care about structs when modding KeeperRL because they are often populated by the mod files we write. This web
		page accesses GitHub and tries to analyse how the structs in Michal's KeeperRL source code might be
		populated should they require population when writing the mod files.
	</h3>
	<div class="usage-info" id="usageInfo">
		Checking GitHub API usage...
	</div>	
    <p>Enter a GitHub repository URL (e.g., https://github.com/username/repo):</p>
    <input type="text" id="repoInput" value="https://github.com/miki151/keeperrl" size="50">
    <button onclick="extractStructsFromRepo()">Extract Structs</button>

    <h2>Current Process:</h2>
    <p id="statusLabel">Waiting for input...</p>

    <h2>File Iteration Progress:</h2>
    <div class="progress-container">
        <div class="progress-bar">
            <div id="fileProgress" class="progress"></div>
        </div>
    </div>

    <h2>Extracted Structs:</h2>
    <div id="result"></div>

    <script>
        async function extractStructsFromRepo() {
            const repoUrl = document.getElementById('repoInput').value;
            const resultDiv = document.getElementById('result');
            const fileProgress = document.getElementById('fileProgress');
            const statusLabel = document.getElementById('statusLabel');
            
            resultDiv.innerHTML = '';
            fileProgress.style.width = '0%';
            statusLabel.innerHTML = 'Fetching repository contents...';

            try {
                // Extract owner and repo name from GitHub URL
                const repoParts = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
                if (!repoParts) {
                    throw new Error('Invalid GitHub repository URL');
                }

                const owner = repoParts[1];
                const repo = repoParts[2];

                // GitHub API URL for repository content (root directory, master branch)
                const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/`;

                // Fetch the repository contents from GitHub
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    throw new Error('Error fetching repository contents from GitHub');
                }

                const files = await response.json();
                const sourceFiles = files.filter(file => file.type === 'file' && (file.name.endsWith('.h') || file.name.endsWith('.cpp')));
                const totalFiles = sourceFiles.length;

                if (totalFiles === 0) {
                    resultDiv.innerHTML = 'No .h or .cpp files found in the repository.';
                    statusLabel.innerHTML = 'No files found.';
                    return;
                }

                let fileIndex = 0;

                // Iterate over each source file and process .h or .cpp files
                for (const file of sourceFiles) {
                    // Update the file iteration progress bar
                    fileIndex++;
                    const fileProgressPercent = (fileIndex / totalFiles) * 100;
                    fileProgress.style.width = `${fileProgressPercent}%`;
                    fileProgress.innerText = `${Math.round(fileProgressPercent)}%`;

                    statusLabel.innerHTML = `Processing file: ${file.name} (${fileIndex}/${totalFiles})`;

                    const rawUrl = file.download_url;
                    const fileResponse = await fetch(rawUrl);
                    const fileContent = await fileResponse.text();

                    // Remove comments from the file content
                    let cleanedContent = fileContent.replace(/\/\/.*|\/\*[^]*?\*\//g, '');

                    // Normalize the file content by replacing all whitespace with a single space
                    const normalizedContent = cleanedContent.replace(/\s+/g, ' ');

                    // Extract structs from each file and update the output
                    extractAndDisplayStructs(normalizedContent, file.name);
                }

                statusLabel.innerHTML = 'Processing complete.';
                fileProgress.style.width = '100%';
                fileProgress.innerText = '100%';
            } catch (error) {
                resultDiv.innerHTML = `Error: ${error.message}`;
                statusLabel.innerHTML = 'Error occurred.';
            }
        }

function extractAndDisplayStructs(sourceCode, fileName) {
    const resultDiv = document.getElementById('result');
    const structs = sourceCode.split('struct'); // Split the source into structs
    let output = '';

    // Iterate through each struct definition
    structs.forEach(struct => {
        if (struct.trim()) { // Check if not empty
			// Replace specified keywords in the struct
            const structNameMatch = struct.match(/^\s*(\w+)/); // Match the first word // Match struct name
            if (structNameMatch) {


                const structName = structNameMatch[1].trim();
                const membersOutput = [];
                let serializeLine = '';

                // Split the struct body into lines for easier processing
                const lines = struct.split(';');
                lines.forEach(line => {
                    const trimmedLine = line.trim();
                    if (trimmedLine.startsWith('SERIALIZE_ALL')) {
                        serializeLine = trimmedLine; // Capture the SERIALIZE_ALL line
                    } else if (trimmedLine.includes('SERIAL')) {
                        membersOutput.push(trimmedLine); // Collect member definitions
                    }
                });

                // If no members or SERIALIZE_ALL line, skip this struct
                if (serializeLine || membersOutput.length > 0) {
                    // Create the usage section based on the SERIALIZE_ALL line
                    let usageSection = serializeLine.replace('SERIALIZE_ALL(', `<b>${structName}</b> `); // Replace SERIALIZE_ALL with structName
                    usageSection = usageSection
                        .replace(/\s+/g, ' ') // Remove any whitespace
                        .replace(/,/g, ' ') // Replace commas with spaces
                        .replace(/\);/g, '') // Remove any ); occurrences
                        .replace(/NAMED\(/g, '{') // Replace NAMED( with {
                        .replace(/OPTION\(/g, '{') // Replace OPTION( with {
                        .replace(/SKIP\(/g, '{') // Replace SKIP( with {
                        .replace(/\)/g, '}') // Replace ) with }
                        .replace('} ITEM_TYPE_INTERF', '') // Remove unwanted parts
						.replace('SUBCLASS(Summon}','{summon}')
						.replace('SUBCLASS(GenericModifierEffect}','{effect}')
                        .replace('  ', ' ') // Replace double spaces
                        .slice(0, -3); // Remove the last 3 characters

					if (usageSection.trim()) {
						// Format output with expandable details
						output += `${usageSection.trim()}<details>File: ${fileName.trim()}
Struct Name: ${structName.trim()}
${membersOutput.join('\n')}
${serializeLine.trim()}
</details><br/>`;
					}
                }
            }
        }
    });

    resultDiv.innerHTML += output; // Append to result div
}

		// Function to fetch GitHub API usage data
		async function fetchUsageData() {
			try {
				const response = await fetch('https://api.github.com/rate_limit');
				const data = await response.json();
				const limit = data.rate.limit;
				const remaining = data.rate.remaining;
				const resetTime = new Date(data.rate.reset * 1000);
				
				// Calculate time left in seconds
				const now = new Date();
				const timeLeft = Math.floor((resetTime - now) / 1000); // Difference in seconds
				
					// Only show usage information if relevant
				if (remaining < limit) {
					const usageInfo = `
						You have <span class="highlight">${remaining}</span> requests remaining from <span class="highlight">${limit}</span>.
						<br>Next Reset Time (UTC): <span class="highlight">${resetTime.toLocaleString('en-GB', { timeZone: 'UTC' })}</span>
					`;
					document.getElementById('usageInfo').innerHTML = usageInfo;
				} else {
					document.getElementById('usageInfo').innerHTML = '';
				}
			} catch (error) {
				document.getElementById('usageInfo').innerHTML = 'Error fetching GitHub API usage data.';
				console.error('Error:', error);
			}
		}

		// Fetch the usage data on page load
		fetchUsageData();
		setInterval(fetchUsageData, 60000);
    </script>
</body>
</html>
