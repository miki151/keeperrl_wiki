<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KeeperRL Struct Extractor from GitHub</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        #result {
            white-space: pre-wrap;
            background-color: #f4f4f4;
            padding: 10px;
            border: 1px solid #ddd;
            margin-top: 10px;
            height: 300px;
            overflow-y: scroll;
        }
        .progress-container {
            margin-top: 10px;
        }
        .progress-bar {
            width: 100%;
            background-color: #f3f3f3;
        }
        .progress {
            width: 0;
            height: 20px;
            background-color: #4caf50;
            text-align: center;
            color: white;
        }
    </style>
</head>
<body>
    <h1>C++ Struct Extractor from GitHub</h1>
	<div class="usage-info" id="usageInfo">
		Checking GitHub API usage...
	</div>	
    <p>Enter a GitHub repository URL (e.g., https://github.com/username/repo):</p>
    <input type="text" id="repoInput" value="https://github.com/miki151/keeperrl" size="50">
    <button onclick="extractStructsFromRepo()">Extract Structs</button>

    <h2>Current Process:</h2>
    <p id="statusLabel">Waiting for input...</p>

    <h2>File Iteration Progress:</h2>
    <div class="progress-container">
        <div class="progress-bar">
            <div id="fileProgress" class="progress"></div>
        </div>
    </div>

    <h2>Extracted Structs:</h2>
    <div id="result"></div>

    <script>
        async function extractStructsFromRepo() {
            const repoUrl = document.getElementById('repoInput').value;
            const resultDiv = document.getElementById('result');
            const fileProgress = document.getElementById('fileProgress');
            const statusLabel = document.getElementById('statusLabel');
            
            resultDiv.innerHTML = 'Fetching files from repository...';
            fileProgress.style.width = '0%';
            statusLabel.innerHTML = 'Fetching repository contents...';

            try {
                // Extract owner and repo name from GitHub URL
                const repoParts = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
                if (!repoParts) {
                    throw new Error('Invalid GitHub repository URL');
                }

                const owner = repoParts[1];
                const repo = repoParts[2];

                // GitHub API URL for repository content (root directory, master branch)
                const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/`;

                // Fetch the repository contents from GitHub
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    throw new Error('Error fetching repository contents from GitHub');
                }

                const files = await response.json();
                const sourceFiles = files.filter(file => file.type === 'file' && (file.name.endsWith('.h') || file.name.endsWith('.cpp')));
                const totalFiles = sourceFiles.length;

                if (totalFiles === 0) {
                    resultDiv.innerHTML = 'No .h or .cpp files found in the repository.';
                    statusLabel.innerHTML = 'No files found.';
                    return;
                }

                let fileIndex = 0;

                // Iterate over each source file and process .h or .cpp files
                for (const file of sourceFiles) {
                    // Update the file iteration progress bar
                    fileIndex++;
                    const fileProgressPercent = (fileIndex / totalFiles) * 100;
                    fileProgress.style.width = `${fileProgressPercent}%`;
                    fileProgress.innerText = `${Math.round(fileProgressPercent)}%`;

                    statusLabel.innerHTML = `Processing file: ${file.name} (${fileIndex}/${totalFiles})`;

                    const rawUrl = file.download_url;
                    const fileResponse = await fetch(rawUrl);
                    const fileContent = await fileResponse.text();

                    // Remove comments from the file content
                    let cleanedContent = fileContent.replace(/\/\/.*|\/\*[^]*?\*\//g, '');

                    // Normalize the file content by replacing all whitespace with a single space
                    const normalizedContent = cleanedContent.replace(/\s+/g, ' ');

                    // Extract structs from each file and update the output
                    extractAndDisplayStructs(normalizedContent, file.name);
                }

                statusLabel.innerHTML = 'Processing complete.';
                fileProgress.style.width = '100%';
                fileProgress.innerText = '100%';
            } catch (error) {
                resultDiv.innerHTML = `Error: ${error.message}`;
                statusLabel.innerHTML = 'Error occurred.';
            }
        }

function extractAndDisplayStructs(sourceCode, fileName) {
    const resultDiv = document.getElementById('result');
    const structs = sourceCode.split('struct'); // Split the source into structs
    let output = '';

    // Iterate through each struct definition
    structs.forEach(struct => {
        if (struct.trim()) { // Check if not empty
            const structNameMatch = struct.match(/(\w+)\s*\{/); // Match struct name
            if (structNameMatch) {
                const structName = structNameMatch[1].trim();
                const membersOutput = [];
                let serializeLine = '';

                // Split the struct body into lines for easier processing
                const lines = struct.split(';');
                lines.forEach(line => {
                    const trimmedLine = line.trim();
                    if (trimmedLine.startsWith('SERIALIZE_ALL')) {
                        serializeLine = trimmedLine; // Capture the SERIALIZE_ALL line
                    } else if (trimmedLine.includes('SERIAL')) {
                        membersOutput.push(trimmedLine); // Collect member definitions
                    }
                });

				// Create the usage section based on the SERIALIZE_ALL line
				let usageSection = serializeLine.replace('SERIALIZE_ALL(', `<b>${structName}</b> `); // Replace SERIALIZE_ALL with structName
				usageSection = usageSection
					.replace(/\s+/g, ' ') // Remove any whitespace
					.replace(/,/g, ' ') // Replace commas with spaces
					.replace(/\);/g, '') // Remove any ); occurrences
					.replace(/NAMED\(/g, '{') // Replace NAMED( with {
					.replace(/OPTION\(/g, '{') // Replace OPTION( with {
					.replace(/SKIP\(/g, '{') // Replace SKIP( with {
					.replace(/\)/g, '}') // Replace ) with }
					.replace('SUBCLASS(GenericModifierEffect}','effect')
					.replace('} ITEM_TYPE_INTERF','')
					.slice(0, -3); // Remove the last 3 characters
					
                if (output.includes('roundBracket{)')) {
                    output = output.replace(/withRoundBracket\{\)/g, '('); // Replace roundBracket{ with (
                    output += ')'; // Ensure the output ends with )
                }

                // Only add if it's not just whitespace
                const formattedUsage = usageSection.trim();
                if (formattedUsage) {
                    output += `File: ${fileName}\nStruct Name: ${structName}\nMembers:\n${membersOutput.join('\n')}\n${serializeLine}\n\nMod File Usage:\n${formattedUsage}\n\n`;
                }
            }
        }
    });

    resultDiv.innerHTML += output; // Append to result div
}


		// Function to fetch GitHub API usage data
		async function fetchUsageData() {
			try {
				const response = await fetch('https://api.github.com/rate_limit');
				const data = await response.json();

				const limit = data.rate.limit;
				const remaining = data.rate.remaining;
				const resetTime = new Date(data.rate.reset * 1000); // Keep as Date object

				// Format reset time for local time zone
				const resetTimeFormatted = new Intl.DateTimeFormat(navigator.language, {
					dateStyle: 'medium',
					timeStyle: 'medium',
				}).format(resetTime);
				
				// Calculate time left in seconds
				const now = new Date();
				const timeLeft = Math.floor((resetTime - now) / 1000); // Difference in seconds
				
				const usageInfo = `
					It will use your GitHub API allowance which is <span class="highlight">${limit}</span> per hour for unidentified IP addresses and <span class="highlight">5000</span> for authorized GitHub token holders. 
					<br>
					You have <span class="highlight">${remaining}</span> requests remaining. 
					<br>
					Next Reset Time (UTC): <span class="highlight">${resetTime.toLocaleString('en-GB', { timeZone: 'UTC' })}</span>
					<br>
					Next Github API allowance: <span class="highlight">${timeLeft > 0 ? timeLeft : 0}</span> seconds from ${now}
					<br>
					It is designed to prevent you spamming past your limit.
					<br>
					ðŸ‘¾ Soft Monster ðŸ‘¾ <span id="currentTime"></span>
					<br>
					If you don't know what GitHub API usage is, it is unlikely you need extra in the next hour.
					<p>
						You can learn about GitHub API usage from the official documentation:
						<a href="https://docs.github.com/en/rest" target="_blank">GitHub REST API Documentation</a>
					</p>					
				`;
				
				document.getElementById('usageInfo').innerHTML = usageInfo;
				
                // If remaining requests are zero display warning.
                if (remaining === 0) {
                    displayApiError(`GitHub API rate limit exceeded. Please wait and try again after <strong>Next Reset Time (UTC):</strong> ${resetTime}.`);
                }				
			} catch (error) {
				document.getElementById('usageInfo').innerHTML = 'Error fetching GitHub API usage data. Please try again later.';
				console.error('Error:', error);
			}
		}

        // Fetch the usage data on page load
        fetchUsageData();
        setInterval(fetchUsageData, 60000);
    </script>
</body>
</html>
